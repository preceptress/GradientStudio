<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>iOS Gradient Models + iPhone Mockup</title>

  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />

  <style>
    body { background-color: #0b0c10; color: #e9ecef; }

    /* Gradient animation reused everywhere */
    @keyframes gradientShift {
      0%   { background-position: 0% 50%; }
      50%  { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    .gradient-animate {
      background: linear-gradient(120deg, #6a79ff, #8b5cf6, #ec4899, #facc15);
      background-size: 300% 300%;
      animation: gradientShift 6s linear infinite;
    }

    /* Phone mockup frame */
    #iphone-inline-button .phone-frame {
      width: 320px;
      height: 680px;
      overflow: hidden;
      border-radius: 2rem;
    }

    /* Blend button inside phone */
    #iphone-inline-button .phone-blend-btn {
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 1rem;
      padding: 0.75rem 2rem;
      color: #fff;
      font-weight: 600;
    }

    /* Code block styling */
    pre { margin: 0; color: #e5e7eb; background: #0b0b0c; font-size: 0.9rem; }
  </style>
</head>
<body>

  <main class="container my-5">

    <!-- ===== Full-screen animated gradient model ===== -->
    <section id="fullscreen-model" class="mb-5">
      <div id="fullscreenGrad"
           class="gradient-animate d-flex align-items-center justify-content-center"
           style="width:100%; height:80vh; border-radius:1rem;">
        <div class="text-center text-white">
          <h2 class="fw-bold">Full-Screen iOS Model</h2>
          <p class="lead">Live gradient background demo</p>
        </div>
      </div>
    </section>

    <!-- ===== iPhone mockup with Blend button + code + exports ===== -->
    <section id="iphone-inline-button" class="my-5">
      <div class="row g-4">
        <!-- Phone mockup -->
        <div class="col-md-6 d-flex justify-content-center">
          <div class="position-relative phone-frame bg-black border border-secondary shadow-lg">
            <div id="phoneGrad" class="position-absolute top-0 start-0 w-100 h-100 gradient-animate"></div>
            <div class="position-absolute top-50 start-50 translate-middle">
              <button id="phoneBtn" class="btn btn-lg text-white gradient-animate phone-blend-btn">
                Blend
              </button>
            </div>
          </div>
        </div>

        <!-- Controls + Code + Export -->
        <div class="col-md-6">

          <!-- Palette controls -->
          <div class="card bg-dark border-secondary mb-3">
            <div class="card-body d-flex flex-wrap align-items-center gap-3">
              <div class="text-secondary small me-2">Gradient colors:</div>
              <input id="c1" type="color" value="#6a79ff" class="form-control form-control-color" title="Color 1">
              <input id="c2" type="color" value="#8b5cf6" class="form-control form-control-color" title="Color 2">
              <input id="c3" type="color" value="#ec4899" class="form-control form-control-color" title="Color 3">
              <input id="c4" type="color" value="#facc15" class="form-control form-control-color" title="Color 4">
              <div class="form-check ms-auto">
                <input class="form-check-input" type="checkbox" id="autoSync" checked>
                <label class="form-check-label small" for="autoSync">Auto-sync code</label>
              </div>
            </div>
          </div>

          <!-- Export buttons -->
          <div class="mb-3 d-flex flex-wrap gap-2">
            <button id="exportBlendBtn" type="button" class="btn btn-outline-light btn-sm">
              Export: Blend Button (Playground)
            </button>
            <button id="exportFullscreenBtn" type="button" class="btn btn-outline-light btn-sm">
              Export: Full-Screen iOS Model (Playground)
            </button>
          </div>

          <!-- Swift code preview -->
          <div class="bg-black border border-secondary rounded p-3" style="max-height:420px; overflow:auto;">
            <small class="text-muted d-block mb-2">SwiftUI • ContentView.swift</small>
<pre><code id="swiftCodeBlock">// SwiftUI code will update automatically when you change the palette</code></pre>
          </div>
        </div>
      </div>
    </section>

  </main>

  <!-- Footer -->
  <footer class="container border-top border-secondary pt-3 pb-5 text-center text-secondary">
    <small>© 2025 — Preceptress.ai</small>
  </footer>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <!-- JSZip + FileSaver -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <!-- Live palette sync + Swift generation -->
  <script>
    const els = {
      c1: document.getElementById('c1'),
      c2: document.getElementById('c2'),
      c3: document.getElementById('c3'),
      c4: document.getElementById('c4'),
      auto: document.getElementById('autoSync'),
      full: document.getElementById('fullscreenGrad'),
      phoneBg: document.getElementById('phoneGrad'),
      phoneBtn: document.getElementById('phoneBtn'),
      swift: document.getElementById('swiftCodeBlock'),
    };

    function hexToRgbFloats(hex) {
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (!m) return [1,1,1];
      const r = parseInt(m[1], 16) / 255;
      const g = parseInt(m[2], 16) / 255;
      const b = parseInt(m[3], 16) / 255;
      return [r,g,b].map(v => Math.round(v * 100) / 100);
    }

    function currentPalette() {
      return [els.c1.value, els.c2.value, els.c3.value, els.c4.value];
    }

    function cssGradientStr(cols) {
      return `linear-gradient(120deg, ${cols.join(', ')})`;
    }

    function applyPaletteToSurfaces(cols) {
      const img = cssGradientStr(cols);
      [els.full, els.phoneBg, els.phoneBtn].forEach(el => {
        if (!el) return;
        el.style.backgroundImage = img;
        el.style.backgroundSize = '300% 300%';
      });
    }

    function swiftColorLiteral(hex) {
      const [r,g,b] = hexToRgbFloats(hex);
      return `Color(red: ${r}, green: ${g}, blue: ${b})`;
    }

    function makeSwiftCode(cols) {
      const swiftCols = cols.map(swiftColorLiteral).join(',\n                            ');
      return `// Single "Blend" Button with animated gradient fill (palette-synced)
import SwiftUI

struct ContentView: View {
    var body: some View {
        ZStack {
            LinearGradient(
                colors: [
                    ${swiftCols}
                ],
                startPoint: .topLeading, endPoint: .bottomTrailing
            )
            .ignoresSafeArea()
            VStack {
                BlendButton(title: "Blend", colors: [
                    ${swiftCols}
                ])
            }
        }
    }
}

struct BlendButton: View {
    let title: String
    let colors: [Color]
    @State private var t: CGFloat = 0

    var body: some View {
        Button(action: {}) {
            Text(title)
                .font(.system(size: 22, weight: .semibold, design: .rounded))
                .foregroundColor(.white)
                .padding(.vertical, 16)
                .padding(.horizontal, 28)
                .background(
                    LinearGradient(colors: colors, startPoint: .topLeading, endPoint: .bottomTrailing)
                )
                .clipShape(RoundedRectangle(cornerRadius: 18, style: .continuous))
                .overlay(
                    RoundedRectangle(cornerRadius: 18, style: .continuous)
                        .stroke(Color.white.opacity(0.18), lineWidth: 1)
                )
                .shadow(color: .white.opacity(0.08), radius: 20, y: 8)
        }
        .onAppear {
            withAnimation(.linear(duration: 5).repeatForever(autoreverses: false)) {
                t = 1
            }
        }
    }
}

#Preview { ContentView() }`;
    }

    function refreshAll() {
      const cols = currentPalette();
      applyPaletteToSurfaces(cols);
      if (els.auto?.checked && els.swift) {
        els.swift.textContent = makeSwiftCode(cols);
      }
    }

    ['input', 'change'].forEach(ev => {
      [els.c1, els.c2, els.c3, els.c4].forEach(inp => inp?.addEventListener(ev, refreshAll));
    });
    els.auto?.addEventListener('change', refreshAll);

    refreshAll();

    function swiftForBlendPlayground() {
      const cols = currentPalette().map(swiftColorLiteral).join(',\n                            ');
      return `import SwiftUI
import PlaygroundSupport

struct ContentView: View {
    var body: some View {
        ZStack {
            Color.black.ignoresSafeArea()
            BlendButton(title: "Blend", colors: [
                ${cols}
            ])
        }
    }
}

struct BlendButton: View {
    let title: String
    let colors: [Color]
    @State private var t: CGFloat = 0

    var body: some View {
        Button(action: {}) {
            Text(title)
                .font(.system(size: 22, weight: .semibold, design: .rounded))
                .foregroundColor(.white)
                .padding(.vertical, 16)
                .padding(.horizontal, 28)
                .background(
                    LinearGradient(colors: colors, startPoint: .topLeading, endPoint: .bottomTrailing)
                )
                .clipShape(RoundedRectangle(cornerRadius: 18, style: .continuous))
        }
        .onAppear {
            withAnimation(.linear(duration: 5).repeatForever(autoreverses: false)) { t = 1 }
        }
    }
}

PlaygroundPage.current.setLiveView(ContentView())`;
    }

    function swiftForFullScreenPlayground() {
      const cols = currentPalette().map(swiftColorLiteral).join(',\n                    ');
      return `import SwiftUI
import PlaygroundSupport

struct ContentView: View {
    var body: some View {
        LinearGradient(
            colors: [
                ${cols}
            ],
            startPoint: .topLeading, endPoint: .bottomTrailing
        )
        .ignoresSafeArea()
    }
}

PlaygroundPage.current.setLiveView(ContentView())`;
    }

    async function downloadPlaygroundZip({ title, contentsSwift }) {
      if (typeof JSZip === "undefined" || typeof saveAs === "undefined") {
        alert("Export requires JSZip + FileSaver.");
        return;
      }
      const safe = title.replace(/\s+/g, "");
      const folder = safe + ".playground";
      const xc = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<playground version='5.0' target-platform='ios' display-mode='raw' executeOnSourceChanges='true'></playground>`;
      const zip = new JSZip();
      const root = zip.folder(folder);
      root.file("Contents.swift", contentsSwift);
      root.file("contents.xcplayground", xc);
      const blob = await zip.generateAsync({ type: "blob" });
      saveAs(blob, `${folder}.zip`);
    }

    document.getElementById("exportBlendBtn")?.addEventListener("click", () =>
      downloadPlaygroundZip({ title: "BlendButton", contentsSwift: swiftForBlendPlayground() })
    );

    document.getElementById("exportFullscreenBtn")?.addEventListener("click", () =>
      downloadPlaygroundZip({ title: "FullScreenGradientModel", contentsSwift: swiftForFullScreenPlayground() })
    );
  </script>
</body>
</html>